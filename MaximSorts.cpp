#include <stdlib.h> // Стандартная библиотека

// Функция для обмена переменных значениями 
void swap(int *a, int *b)
{
    int temp = *a;
    *a = *b;
    *b = temp;
}

// Сортировка пузырьком (принцип лучше загуглить)
// Сложность сортировки O(n^2)
void bubble_sort(int *arr, size_t len, int (*cmp)(int, int))
{
    for (size_t i = 0; i < len - 1; ++i)
        for (size_t j = 0; j < len - i - 1; ++j)
            // Если элементы находятся в неправильном порядке то меняем их местами
            if (cmp(arr[j], arr[j + 1]) > 0) 
                swap(&arr[j], &arr[j + 1]);
}

// Сортировка вставкой (принцип работы загуглить)
// Сложность сортировки O(n^2) (на малых массивах быстрее всего из-за наименьшего кол-ва перестановок)
void insertion_sort(int *arr, size_t len, int (*cmp)(int, int))
{
    // Итерируемся по массиву
    for (size_t i = 1; i < len; ++i)
    {
        int j;
        int cur = arr[i]; // Текущий элемент
        // Ищем такое место в отсортированной части массива, что при вставке текущего элемента подмассив длиной i + 1 станет отсортированным
        for (j = i - 1; j >= 0 && cmp(cur, arr[j]) < 0; --j)
            arr[j + 1] = arr[j];
        // Вставляем текущий элемент на нужное нам место
        arr[j + 1] = cur;
    }
}

// Функция для получения следующего зазора для сортировки расческой
int get_next_gap(int gap)
{
    gap = gap * 10 / 13; // Разделим предыдущий зазор на 1.3 (величина высчитывается эмпирическим путем)

    if (gap < 1) // Если зазор меньше 1 возвратим 1
        return 1;
    return gap;
}

// Сортировка расческой
// Сложность O(n^2)
void comb_sort(int *arr, size_t len, int (*cmp)(int, int))
{
    int gap = len; // Зададим начальный зазор как длину массива
    int swapped = 1; // Зададим флаг того, было ли произведена хотя бы одна перестановка, как TRUE

    while (gap != 1 || swapped) // Пока зазор не равен 1 или была произведена хотя бы одна перестановка
    {
        gap = get_next_gap(gap); // Получаем следующий зазор
        swapped = 0; // Задаем флаг как FALSE

        for (size_t i = 0; i < len - gap; ++i) // Итерируемся по массиву до len - gap
        {
            // Если элементы на i и i + gap находятся в неправильном порядке, то меняем их местами и задаем флаг swapped как TRUE
            if (cmp(arr[i], arr[i + gap]) > 0)
            {
                swap(&arr[i], &arr[i + gap]);
                swapped = 1;
            }
        }
    }
}

// Сортировка Шелла
// Сложность O(n^2)
// Является усложненным вариантом сортировки вставкой
void shell_sort(int *arr, size_t len, int (*cmp)(int, int))
{
    // Будем итерироваться по массиву пока зазор, 
    //заданный изначально как длина массива 
    // поделенная на 2 и с каждой итерацией уменьшаемая в два раза
    // не будет равен 0
    for (size_t gap = len / 2; gap > 0; gap /= 2)
        // Итерируемся от gap от len
        for (size_t i = gap; i < len; ++i)
        {
            int cur = arr[i]; // Текущий элемент
            size_t j;
            // Ищем на какое место вставить текущий элемент попутно сдвигая другие элементы вправо
            for (j = i; j >= gap && cmp(cur, arr[j - gap]) < 0; j -= gap)
                arr[j] = arr[j - gap];

            arr[j] = cur; // На нужное место вставляем текущий элемент
        }
}
